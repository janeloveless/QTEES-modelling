#! /usr/bin/python3

# native python imports
import itertools as it
from abc import ABC, abstractmethod

# required external module imports
import numpy as np
import scipy as sp
import scipy.linalg
import scipy.interpolate
import matplotlib.pyplot as plt

# optional external module imports
try :
    from tqdm import trange
    pretty_range = trange
except ModuleNotFoundError :
    print("TQDM isn't installed. Progress bars will be disabled.")
    pretty_range = range



class DynamicModel(ABC) :
    """
    This abstract class defines the interface to be used for all dynamic models.

    It concretely implements common numerical integration methods (Euler, RK4).

    attributes
        trajectory              stores the latest trajectory generated by the model
        time_axis               stores the time_axis corresponding to trajectory
        N_state                 dimension of state space
        N_control               dimension of control space
        
    methods
        evolution_rule          gives the time derivative of the state vector
        generate_trajectory     uses the evolution rule to produce a state trajectory 
        analyse_trajectory      this function is run after a trajectory is generated;
                                it can be used to store derived quantities such as energies
        euler_step              one update step of the Euler method
        RK4_step                one update step of the Runge-Kutta-4 method
    """

    trajectory = None
    time_axis = None

    N_state = None
    N_control = None

    @abstractmethod
    def evolution_rule(self, time, state, inputs=None) : 
        raise NotImplementedError

    def generate_trajectory(self, initial_state, duration, time_step, integrator="RK4") :
        print("generating trajectory...")

        # set up integration method to be used
        if integrator == "Euler" :
            integration_step = self.euler_step
        elif integrator == "RK4" :
            integration_step = self.RK4_step

        time_axis = self.generate_time_axis(duration, time_step)
        
        trajectory = [initial_state]
        for i in pretty_range(len(time_axis) - 1) :
            current_state = trajectory[i]
            current_time = time_axis[i]
            next_state = integration_step(current_time, current_state, time_step)
            trajectory.append(next_state)
        trajectory = np.array(trajectory)

        self.time_axis = time_axis
        self.trajectory = trajectory

        self.analyse_trajectory()

        return time_axis, trajectory

    def analyse_trajectory(self) :
        pass

    def generate_time_axis(self, duration, time_step) :
        N_steps = int(duration/time_step)
        time_axis = np.arange(N_steps + 1)*time_step
        return time_axis

    def euler_step(self, time, state, time_step) :
        # the Euler algorithm uses the state and the state's time derivative at this
        # moment in time to predict the state one "step" into the future
        next_state = state + self.evolution_rule(time, state)*time_step
        return next_state

    def RK4_step(self, time, state, time_step) :
        # RK4 algorithm uses a weighted average of derivative estimates at beginning,
        # midpoint, and end of the time step. Contrast this with Euler, where we use
        # only the derivative estimate at the *beginning* of the interval.
        half_step = time_step/2
        start = time
        midpoint = time + half_step
        end = time + time_step

        # first we find the derivative at the start of the interval 
        k1 = self.evolution_rule(start, state)

        # we then do "half" an Euler step, to estimate the state at the midpoint of
        # the time interval
        euler_midpoint_state_estimate = state + k1*half_step

        # we use this midpoint Euler state estimate to estimate the derivative at the
        # midpoint of the interval
        k2 = self.evolution_rule(midpoint, euler_midpoint_state_estimate)

        # then we update our midpoint state estimate, by taking another "half" Euler
        # step, but this time using the midpoint derivative estimate
        updated_euler_midpoint_state_estimate = state + k2*half_step

        # we use this to update our midpoint derivative estimate
        k3 = self.evolution_rule(midpoint, updated_euler_midpoint_state_estimate)

        # we then take a "full" Euler step, using our updated midpoint derivative estimate
        updated_euler_end_state_estimate = state + k3*time_step

        # and we use this to estimate the derivative at the end of the interval
        k4 = self.evolution_rule(end, updated_euler_end_state_estimate)

        # we now form an estimate of the derivative throughout the entire interval by
        # taking a weighted average of our single-point derivative estimates. More
        # weight is given to our midpoint estimates than those at the start/end of
        # the interval.
        RK4_derivative_estimate = (1/6)*(k1 + 2*k2 + 2*k3 + k4)

        # finally, we do an Euler-like step using this averaged derivative estimate
        return state + RK4_derivative_estimate*time_step


class CoupledDynamicModel(DynamicModel) :
    def __init__(self, dynamic_models, coupling_matrix) :
        self.dynamic_models = list(dynamic_models)
        self.coupling_matrix = coupling_matrix
        self.N_states = [dm.N_state for dm in dynamic_models]
        self.N_controls = [dm.N_control for dm in dynamic_models]
        self.N_state = sum(self.N_states)
        self.N_control = sum(self.N_controls)
        self.N_subsystems = len(self.dynamic_models)

        assert coupling_matrix.shape == (self.N_control, self.N_state),\
            "dimensions of coupling matrix do not match dimensions of state and control spaces"

    def evolution_rule(self, time, state, inputs=None) :
        input_vector = np.dot(self.coupling_matrix, state)
        subsystem_inputs = self.split_vector(input_vector, self.N_controls)
        subsystem_states = self.split_vector(state, self.N_states)
        subsystem_dynamics = [dm.evolution_rule(time, subsystem_state, subsystem_input) 
                                for dm, subsystem_state, subsystem_input 
                                in zip(self.dynamic_models, subsystem_states, subsystem_inputs)]
        return np.concatenate(subsystem_dynamics)
        

    def analyse_trajectory(self) :
        subsystem_trajectories = self.split_vector(self.trajectory.T, self.N_states)
        for dm, trajectory in zip(self.dynamic_models, subsystem_trajectories) :
            dm.time_axis = self.time_axis
            dm.trajectory = trajectory.T
            dm.analyse_trajectory()

    def split_vector(self, vector, dimensions) :
        N_subsystems = len(dimensions)
        assert sum(dimensions) == len(vector), \
                "dimensions of sub-vectors do not sum to original vector dimension"
        split_indices = np.cumsum([0] + dimensions)
        vectors = [vector[split_indices[i]:split_indices[i + 1]] for i in
                    range(N_subsystems)]
        return vectors


class LeakyIntegrator(DynamicModel) :
    """
    Implements classic leaky integrator dynamics. Useful for testing, or simplistic
    modelling of some relaxational systems (e.g. synaptic decay).
    """

    N_state = 1
    N_control = 1
    analysis_complete = False   # TODO remove once testing completed!

    def __init__(self, rate=1) :
        """
        Constructor.
        
        rate        rate constant
        input       instance of Input class
        """
        self.rate = rate

    def evolution_rule(self, time, state, control=0) :
        Dstate = -self.rate*(state - control)
        return Dstate

    def analyse_trajectory(self) :
        self.analysis_complete = True


if __name__ == "__main__" :
    N_subsystems = 10
    subsystems = [LeakyIntegrator() for i in range(N_subsystems)]
    coupling_matrix = (0.2*10**(0))*np.random.randn(N_subsystems, N_subsystems)
    CDM = CoupledDynamicModel(subsystems, coupling_matrix)

    initial_state = np.random.randn(N_subsystems)
    time_axis, trajectory = CDM.generate_trajectory(initial_state, 10, 0.01)

    [plt.plot(time_axis, dm.trajectory.T[0]) for dm in CDM.dynamic_models]
